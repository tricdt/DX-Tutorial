using System;
using System.Globalization;
using System.Linq;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using DevExpress.Xpf.Charts;
using DevExpress.Xpf.DemoBase;

namespace ChartsDemo {
    [CodeFile("Modules/AppearanceCustomization/AdvancedCustomization.xaml"),
     CodeFile("Modules/AppearanceCustomization/AdvancedCustomization.xaml.(cs)"),
     CodeFile("DataModels/RealEstateData.(cs)"),
     NoAutogeneratedCodeFiles]
    public partial class AdvancedCustomizationDemo : ChartsDemoModule {
        public AdvancedCustomizationDemo() {
            InitializeComponent();
        }

        void chart_BoundDataChanged(object sender, RoutedEventArgs e) {
            ((ChartControl)sender).BoundDataChanged -= chart_BoundDataChanged;
            int firstYear = int.Parse(this.chart.Diagram.Series[0].Points[0].Argument);
            for (int i = firstYear; i < firstYear + 3; i++) {
                SeriesPoint found = null;
                double maxIncome = 0.0;
                foreach (Series series in this.chart.Diagram.Series) {
                    string arg = i.ToString(); 
                    SeriesPoint point = series.Points.Where(sp => sp.Argument == arg).First();
                    if (point.Value > maxIncome) {
                        found = point;
                        maxIncome = point.Value;
                    }
                }
                this.chart.Annotations.Add(new Annotation() {
                    LabelMode = true,
                    Content = found.Tag,
                    AnchorPoint = new SeriesPointAnchorPoint() {
                        SeriesPoint = found
                    }
                });
            }
        }
    }


    enum Months {
        Jan,
        Feb,
        Mar,
        Apr,
        May,
        Jun,
        Jul,
        Aug,
        Sep,
        Oct,
        Nov,
        Dec
    }


    class EmployeeNameToPhotoConverter : ForwardOnlyValueConverter {
        public override object Convert(object value, Type targetType, object parameter, CultureInfo culture) {
            string name = value as string;
            if (name == null)
                return value;
            BitmapImage image = new BitmapImage(new Uri("../../Images/Employees/" + name + ".png", UriKind.Relative));
            return image;
        }
    }


    class AxisValueToLabelTextConverter : ForwardOnlyValueConverter {
        public override object Convert(object value, Type targetType, object parameter, CultureInfo culture) {
            if (value.GetType() != typeof(double))
                return value;
            double doubleValue = (double)value;
            if (doubleValue < 1000)
                return string.Format("${0:0.}", value);
            else if (doubleValue < 1000000)
                return string.Format("${0:0,.}K", value);
            else if (doubleValue < 1000000000)
                return string.Format("${0:0,,.#}M", value);
            return value.ToString();
        }
    }


    class AxisValueToLabelFontSizeConverter : ForwardOnlyValueConverter {
        float CalculateFontSize(double ratio, int minFontSize, int maxFontSize) {
            return (float)(minFontSize + (maxFontSize - minFontSize) * ratio);
        }
        public override object Convert(object value, Type targetType, object parameter, CultureInfo culture) {
            AxisLabelItem item = value as AxisLabelItem;
            if (item == null || item.Value.GetType() != typeof(double))
                return value;
            double doubleValue = (double)item.Value;
            AxisY2D axisY = (AxisY2D)item.Label.Parent;
            double ratio = doubleValue / ((double)axisY.ActualWholeRange.ActualMaxValue + axisY.ActualWholeRange.ActualSideMarginsValue);
            return CalculateFontSize(ratio, 12, 22);
        }
    }


    class AxisValueToLabelForegroundConverter : ForwardOnlyValueConverter {
        public override object Convert(object value, Type targetType, object parameter, CultureInfo culture) {
            AxisLabelItem item = value as AxisLabelItem;
            if (item == null || item.Value.GetType() != typeof(double))
                return value;
            double doubleValue = (double)item.Value;
            AxisY2D axisY = (AxisY2D)item.Label.Parent;
            double ratio = doubleValue / ((double)axisY.ActualWholeRange.ActualMaxValue + axisY.ActualWholeRange.ActualSideMarginsValue);
            Color color = ColorUtils.InterpolateColors(Color.FromArgb(255, 170, 42, 0), Colors.Green, ratio);
            SolidColorBrush brush = new SolidColorBrush(color);
            brush.Freeze();
            return brush;
        }
    }


    
    class BrushToSolidColorBrushConverter : ForwardOnlyValueConverter {
        public override object Convert(object value, Type targetType, object parameter, CultureInfo culture) {
            return value;
        }
    }


    class CustomBarModelPanel : Panel {
        public static readonly DependencyProperty SidesProperty = DependencyProperty.RegisterAttached("Sides",
            typeof(SolidSidesExtended), typeof(CustomBarModelPanel), new PropertyMetadata(SolidSidesExtended.Front));

        public static void SetSides(UIElement element, SolidSides value) {
            element.SetValue(SidesProperty, value);
        }

        public static SolidSidesExtended GetSides(UIElement element) {
            return (SolidSidesExtended)element.GetValue(SidesProperty);
        }

        protected override Size MeasureOverride(Size availableSize) {
            foreach (UIElement child in Children) {
                switch (GetSides(child)) {
                    case SolidSidesExtended.Top:
                    case SolidSidesExtended.Bottom:
                        child.Measure(new Size(availableSize.Width, double.PositiveInfinity));
                        break;
                    case SolidSidesExtended.Right:
                    case SolidSidesExtended.Left:
                        child.Measure(new Size(double.PositiveInfinity, availableSize.Height));
                        break;
                    case SolidSidesExtended.FrontWindow:
                        double width = Math.Floor(availableSize.Width / 5d) * 5d;   
                        double height = Math.Floor(availableSize.Height / 9d) * 9d;
                        height = height < 0 ? 0 : height;
                        child.Measure(new Size(width, height));
                        break;
                    case SolidSidesExtended.Front:
                    default:
                        child.Measure(availableSize);
                        break;
                }
            }
            Size constraint = new Size();
            constraint.Width = double.IsInfinity(availableSize.Width) ? 0 : availableSize.Width;
            constraint.Height = double.IsInfinity(availableSize.Height) ? 0 : availableSize.Height;
            return constraint;
        }
        protected override Size ArrangeOverride(Size finalSize) {
            foreach (UIElement child in Children) {
                switch (GetSides(child)) {
                    case SolidSidesExtended.Top:
                        child.Arrange(new Rect(new Point(0, 0), new Size(finalSize.Width, child.DesiredSize.Height)));
                        break;
                    case SolidSidesExtended.Bottom:
                        child.Arrange(new Rect(new Point(0, finalSize.Height - child.DesiredSize.Height), new Size(finalSize.Width, child.DesiredSize.Height)));
                        break;
                    case SolidSidesExtended.Left:
                        child.Arrange(new Rect(new Point(0, 0), new Size(child.DesiredSize.Width, finalSize.Height)));
                        break;
                    case SolidSidesExtended.Right:
                        child.Arrange(new Rect(new Point(finalSize.Width - child.DesiredSize.Width, 0), new Size(child.DesiredSize.Width, finalSize.Height)));
                        break;
                    case SolidSidesExtended.FrontWindow:
                        double width = Math.Floor(finalSize.Width / 5d) * 5d; 
                        double height = Math.Floor(finalSize.Height / 9d) * 9d;
                        double x = finalSize.Width / 2d - width / 2d;
                        double y = finalSize.Height / 2d - height / 2d;
                        child.Arrange(new Rect(new Point(x, y), new Size(width, height)));
                        break;
                    case SolidSidesExtended.Front:
                    default:
                        child.Arrange(new Rect(new Point(0, 0), finalSize));
                        break;
                }
            }
            return finalSize;
        }
    }


    enum SolidSidesExtended {
        Left = 0,
        Top = 1,
        Right = 2,
        Bottom = 3,
        Front = 4,
        FrontWindow = 5,
    }
}
